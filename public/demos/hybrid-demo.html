<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>4e VTT - Hybrid Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html, body { margin: 0; padding: 0; height: 100%; background: #0f1115; color: #e6e6e6; font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
      #app { display: grid; grid-template-columns: 1fr 320px; grid-template-rows: auto 1fr auto; height: 100%; }
      header { grid-column: 1 / span 2; padding: 8px 12px; border-bottom: 1px solid #1a1d25; display:flex; align-items:center; justify-content:space-between; }
      .title { font-weight: 600; letter-spacing: .5px; }
      .actionbar { display:flex; gap:8px; align-items:center; }
      .slot { font-size:12px; padding:4px 8px; border:1px solid #2a2f3a; border-radius:6px; background:#151923; color:#cfd3da; }
      .slot.disabled { opacity:.5 }
      .slot .count { color:#8ba3c7; margin-left:6px }
      #stage { grid-row: 2; grid-column: 1; position: relative; overflow:hidden; background: #0b0d12; }
      #sidebar { grid-row: 2; grid-column: 2; border-left:1px solid #1a1d25; display:flex; flex-direction:column; }
      #panel { flex:1; padding:12px; overflow:auto; }
      #log { grid-column: 1 / span 2; grid-row: 3; border-top:1px solid #1a1d25; height: 120px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; background:#0b0d12; padding:8px 12px; }
      .btn { background:#1a1f2b; color:#e6e6e6; border:1px solid #2a2f3a; border-radius:6px; padding:6px 10px; cursor:pointer; }
      .btn:disabled { opacity:.5; cursor:not-allowed }
      .row { display:flex; align-items:center; gap:8px; margin-bottom:8px }
      .muted { color:#98a1b3 }
      #log .entry { margin:2px 0; display:flex; gap:8px; align-items:center }
      #log .icon { width:16px; text-align:center }
      #log .msg { white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
      #log .info .icon { color:#a4b0be }
      .connection-status { 
        padding: 4px 8px; 
        border-radius: 4px; 
        font-size: 12px; 
        margin-left: 8px;
      }
      .connected { background: #1a4d2e; color: #4ade80; }
      .disconnected { background: #4d1a1a; color: #f87171; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
  </head>
  <body>
    <div id="app">
      <header>
        <div class="title">4e VTT - Hybrid Demo</div>
        <div class="actionbar">
          <span id="connection-status" class="connection-status disconnected">Disconnected</span>
          <button id="btn-mode-move" class="btn">Move (M)</button>
          <button id="btn-mode-measure" class="btn">Measure (G)</button>
          <div class="slot" id="slot-standard">Std <span class="count" id="cnt-standard">1</span></div>
          <div class="slot" id="slot-move">Move <span class="count" id="cnt-move">1</span></div>
          <div class="slot" id="slot-minor">Minor <span class="count" id="cnt-minor">1</span></div>
          <button id="btn-bootstrap" class="btn">Bootstrap</button>
        </div>
      </header>
      <div id="stage"></div>
      <aside id="sidebar">
        <div id="panel">
          <div class="row"><b>Selected</b> <span id="sel-actor" class="muted">—</span></div>
          <div class="row"><b>HP</b> <span id="hp" class="muted">—</span></div>
          <div class="row"><b>Position</b> <span id="position" class="muted">—</span></div>
        </div>
      </aside>
      <div id="log"></div>
    </div>

    <script type="module">
      import { PixiStage } from '/ui/stage.js'
      import * as Pathing from '/ui/pathing.js'

      const elStage = document.getElementById('stage')
      const elLog = document.getElementById('log')
      const elSel = document.getElementById('sel-actor')
      const elHp = document.getElementById('hp')
      const elPosition = document.getElementById('position')
      const btnMove = document.getElementById('btn-mode-move')
      const btnMeasure = document.getElementById('btn-mode-measure')
      const btnBootstrap = document.getElementById('btn-bootstrap')
      const connectionStatus = document.getElementById('connection-status')

      let mode = 'move'
      let selected = null
      let measureStart = null
      let client = null

      // Local game state (fallback)
      let G = {
        board: { 
          w: 20, 
          h: 20, 
          blockers: [], 
          difficult: [], 
          positions: {}
        },
        actors: {}
      }

      const stage = new PixiStage(elStage)

      function updateConnectionStatus(connected) {
        connectionStatus.textContent = connected ? 'Connected' : 'Disconnected'
        connectionStatus.className = `connection-status ${connected ? 'connected' : 'disconnected'}`
      }

      function appendLog(type, msg) {
        const entry = document.createElement('div')
        entry.className = `entry ${type}`
        entry.innerHTML = `<span class="icon">•</span><span class="msg">${msg}</span>`
        elLog.appendChild(entry)
        elLog.scrollTop = elLog.scrollHeight
      }

      function renderAll() {
        console.log('Rendering with G:', G)
        stage.drawGrid(G.board)
        stage.drawTokens(G)
        renderPanel()
      }

      function renderPanel() {
        if (selected && G.actors[selected]) {
          const actor = G.actors[selected]
          const pos = G.board.positions[selected]
          elSel.textContent = selected
          elHp.textContent = `${actor.hp.current}/${actor.hp.max}`
          elPosition.textContent = pos ? `${pos.x}, ${pos.y}` : '—'
        } else {
          elSel.textContent = '—'
          elHp.textContent = '—'
          elPosition.textContent = '—'
        }
      }

      function setMode(m) { 
        mode = m
        appendLog('info', `Mode: ${m}`)
      }

      async function createMatch() {
        try {
          const res = await fetch('/games/4e/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ numPlayers: 1 })
          })
          const data = await res.json()
          return data.matchID
        } catch (error) {
          console.error('Error creating match:', error)
          return null
        }
      }

      async function startClient() {
        try {
          const matchID = await createMatch()
          if (!matchID) {
            appendLog('error', 'Failed to create match')
            return
          }

          appendLog('info', `Created match: ${matchID}`)

          // Import boardgame.io client dynamically
          const { Client } = await import('https://esm.sh/boardgame.io@0.50.2/client')
          const { SocketIO } = await import('https://esm.sh/boardgame.io@0.50.2/multiplayer')

          // Simple client game definition
          const ClientGame = {
            name: '4e',
            setup: () => ({ /* setup handled by server */ }),
            moves: {
              bootstrapDemo: (G, ctx) => { /* handled by server */ },
              applyManualPatch: (G, ctx, patch) => { /* handled by server */ }
            }
          }

          client = Client({
            game: ClientGame,
            multiplayer: SocketIO({ server: window.location.origin }),
            matchID,
            playerID: '0',
            debug: false
          })

          // Subscribe to state changes
          client.subscribe((state) => {
            console.log('State received:', state ? Object.keys(state) : 'null')
            if (state && state.G) {
              G = state.G
              console.log('Game state: actors=' + (G.actors ? Object.keys(G.actors).length : 0) + ', board=' + (G.board ? 'yes' : 'no'))
              console.log('Board positions:', G.board?.positions)
              console.log('Actors:', G.actors)
              renderAll()
              updateConnectionStatus(true)
              appendLog('info', 'Game state updated')
            } else {
              console.log('No game state received')
            }
          })

          client.start()
          appendLog('info', 'Client started')
          updateConnectionStatus(true)

        } catch (error) {
          appendLog('error', `Client failed: ${error.message}`)
          updateConnectionStatus(false)
        }
      }

      // Event handlers
      btnMove.onclick = () => setMode('move')
      btnMeasure.onclick = () => setMode('measure')
      btnBootstrap.onclick = () => {
        if (client && client.moves && client.moves.bootstrapDemo) {
          try {
            client.moves.bootstrapDemo()
            appendLog('info', 'Bootstrap called')
          } catch (error) {
            appendLog('error', `Bootstrap failed: ${error.message}`)
          }
        } else {
          appendLog('warn', 'Bootstrap not available')
        }
      }

      // Click to select token
      stage.tokenLayer && (stage.tokenLayer.eventMode = 'static')
      stage.tokenLayer && stage.tokenLayer.on('click', (e) => {
        const tgt = e.target
        if (tgt && typeof tgt.name === 'string' && tgt.name.startsWith('token:')) {
          selected = tgt.name.slice('token:'.length)
          renderPanel()
          appendLog('info', `Selected ${selected}`)
        }
      })

      // Move/Measure on click
      stage.app.view.addEventListener('click', (e) => {
        if (!G || !G.board) return
        if (!selected) return

        const rect = stage.app.view.getBoundingClientRect()
        const pt = { x: e.clientX - rect.left, y: e.clientY - rect.top }
        const cell = stage.worldToCell(pt)

        if (mode === 'measure') {
          if (!measureStart) {
            measureStart = cell
            appendLog('info', `Measure start: ${cell.x}, ${cell.y}`)
          } else {
            const dist = Math.max(Math.abs(cell.x - measureStart.x), Math.abs(cell.y - measureStart.y))
            appendLog('info', `Distance: ${measureStart.x},${measureStart.y} → ${cell.x},${cell.y} = ${dist}`)
            measureStart = null
          }
          return
        }

        if (mode === 'move') {
          const from = G.board.positions[selected]
          if (!from) return

          const res = Pathing.findPath(G, from, cell)
          if (!res) { 
            appendLog('warn', 'Path blocked')
            return 
          }

          const to = res.path[res.path.length - 1]
          
          // Try to use boardgame.io if available, otherwise update locally
          if (client && client.moves && client.moves.applyManualPatch) {
            try {
              client.moves.applyManualPatch({ 
                type: 'set', 
                path: `board.positions.${selected}`, 
                value: { x: to.x, y: to.y } 
              })
              appendLog('info', `Moving ${selected} to ${to.x}, ${to.y} (via server)`)
            } catch (error) {
              appendLog('error', `Server move failed: ${error.message}`)
              // Fallback to local update
              G.board.positions[selected] = to
              appendLog('info', `Moving ${selected} to ${to.x}, ${to.y} (local fallback)`)
              renderAll()
            }
          } else {
            // Local update only
            G.board.positions[selected] = to
            appendLog('info', `Moving ${selected} to ${to.x}, ${to.y} (local)`)
            renderAll()
          }
        }
      })

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'm') setMode('move')
        if (e.key.toLowerCase() === 'g') setMode('measure')
        if (e.key === 'Escape') {
          measureStart = null
          appendLog('info', 'Cancelled measurement')
        }
      })

      // Initialize
      appendLog('info', 'Hybrid demo loaded')
      startClient()
      renderAll()
    </script>
  </body>
</html>
