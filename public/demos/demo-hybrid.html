<!DOCTYPE html>
<html>
<head>
    <title>4e VTT Hybrid Demo</title>
    <style>
        body { 
            font-family: monospace; 
            margin: 20px; 
            background: #0f1115; 
            color: #e6e6e6; 
        }
        .controls { 
            margin: 20px 0; 
            padding: 10px; 
            border: 1px solid #2a2f3a; 
            background: #151923;
            border-radius: 6px;
        }
        button { 
            margin: 5px; 
            padding: 5px 10px; 
            background: #1a1f2b; 
            color: #e6e6e6; 
            border: 1px solid #2a2f3a; 
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #243049; }
        .status { 
            margin: 10px 0; 
            padding: 8px; 
            background: #0b0d12; 
            border-radius: 4px;
            font-size: 12px;
        }
        #stage { 
            border: 1px solid #2a2f3a; 
            background: #0b0d12;
            border-radius: 6px;
        }
        .log { 
            margin-top: 10px; 
            padding: 8px; 
            background: #0b0d12; 
            border-radius: 4px;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
</head>
<body>
    <h1>4e VTT Hybrid Demo (Server + Local UI)</h1>
    
    <div class="controls">
        <div><strong>Mode:</strong> 
            <button id="btn-mode-move">Move (M)</button>
            <button id="btn-mode-measure">Measure (G)</button>
            <button id="btn-mode-target">Target (T)</button>
        </div>
        <div><strong>Actions:</strong> 
            <button id="btn-end-turn">End Turn</button>
            <button id="btn-bootstrap">Bootstrap Demo</button>
            <button id="btn-reset">Reset</button>
        </div>
        <div class="status">
            <strong>Status:</strong> <span id="status">Connecting...</span><br>
            <strong>Selected:</strong> <span id="selected">None</span><br>
            <strong>Mode:</strong> <span id="mode">move</span><br>
            <strong>Match ID:</strong> <span id="match-id">None</span>
        </div>
    </div>
    
    <div id="stage"></div>
    <div class="log" id="log"></div>

    <script type="module">
        // Import the stage and pathing modules
        import { PixiStage } from './ui/stage.js'
        import * as Pathing from './ui/pathing.js'
        import * as Templates from './ui/templates.js'

        // Game state
        let G = {
            board: { w: 15, h: 10, blockers: [], difficult: [], positions: {} },
            actors: {},
            turn: { order: [], index: 0 },
            actions: { standard: 1, move: 1, minor: 1 },
            log: [],
            _ts: 0
        }

        let matchID = null

        // UI elements
        const stageEl = document.getElementById('stage')
        const statusEl = document.getElementById('status')
        const selectedEl = document.getElementById('selected')
        const modeEl = document.getElementById('mode')
        const matchIdEl = document.getElementById('match-id')
        const logEl = document.getElementById('log')
        const btnMove = document.getElementById('btn-mode-move')
        const btnMeasure = document.getElementById('btn-mode-measure')
        const btnTarget = document.getElementById('btn-mode-target')
        const btnEndTurn = document.getElementById('btn-end-turn')
        const btnBootstrap = document.getElementById('btn-bootstrap')
        const btnReset = document.getElementById('btn-reset')

        // State
        let mode = 'move'
        let selected = null
        let preview = null
        let measureStart = null
        let currentPower = null

        // Initialize stage
        const stage = new PixiStage(stageEl)
        
        // Initialize with empty state
        render()

        function log(message) {
            const div = document.createElement('div')
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`
            logEl.appendChild(div)
            logEl.scrollTop = logEl.scrollHeight
        }

        async function createMatch() {
            try {
                const res = await fetch('/games/4e/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ numPlayers: 1 })
                })
                const data = await res.json()
                matchID = data.matchID
                matchIdEl.textContent = matchID
                log(`Created match: ${matchID}`)
                return matchID
            } catch (error) {
                log(`Error creating match: ${error.message}`)
                return null
            }
        }

        async function bootstrapDemo() {
            if (!matchID) {
                log('No match ID, creating one...')
                await createMatch()
            }
            
            try {
                const res = await fetch(`/games/4e/${matchID}/moves/bootstrapDemo`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                })
                const data = await res.json()
                log(`Bootstrap result: ${JSON.stringify(data)}`)
                
                // Set up demo data locally
                G = {
                    board: { 
                        w: 15, 
                        h: 10, 
                        blockers: ['5,5', '6,5', '7,5'], 
                        difficult: ['3,3', '4,3', '5,3'], 
                        positions: {
                            'A1': { x: 2, y: 2 },
                            'E1': { x: 8, y: 4 }
                        }
                    },
                    actors: {
                        'A1': { team: 'A', hp: { current: 24, max: 30, temp: 0 } },
                        'E1': { team: 'B', hp: { current: 30, max: 30, temp: 0 } }
                    },
                    turn: { order: ['A1', 'E1'], index: 0 },
                    actions: { standard: 1, move: 1, minor: 1 },
                    log: [],
                    _ts: 0
                }
                render()
                log('Demo data loaded')
            } catch (error) {
                log(`Error bootstrapping: ${error.message}`)
            }
        }

        async function moveToken(actorId, toCell, mode = 'walk') {
            if (!matchID) return
            
            try {
                const res = await fetch(`/games/4e/${matchID}/moves/moveToken`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ actorId, toCell, mode })
                })
                const data = await res.json()
                log(`Move result: ${JSON.stringify(data)}`)
                
                // Update local state
                G.board.positions[actorId] = toCell
                render()
            } catch (error) {
                log(`Error moving token: ${error.message}`)
            }
        }

        function updateStatus() {
            const currentActor = G.turn.order[G.turn.index]
            statusEl.textContent = `Turn: ${currentActor || 'None'}`
            selectedEl.textContent = selected || 'None'
            modeEl.textContent = mode
        }

        function render() {
            stage.drawGrid(G.board)
            stage.drawTokens(G)
            updateStatus()
        }

        function setMode(newMode) {
            mode = newMode
            updateStatus()
            stage.drawPathHighlight(null)
            preview = null
            measureStart = null
        }

        function endTurn() {
            G.turn.index = (G.turn.index + 1) % G.turn.order.length
            G.actions = { standard: 1, move: 1, minor: 1 }
            selected = G.turn.order[G.turn.index]
            updateStatus()
            render()
            log(`Turn ended, now ${selected}'s turn`)
        }

        // Event handlers
        btnMove.onclick = () => setMode('move')
        btnMeasure.onclick = () => setMode('measure')
        btnTarget.onclick = () => setMode('target')
        btnEndTurn.onclick = endTurn
        btnBootstrap.onclick = bootstrapDemo
        btnReset.onclick = () => {
            G = {
                board: { w: 15, h: 10, blockers: [], difficult: [], positions: {} },
                actors: {},
                turn: { order: [], index: 0 },
                actions: { standard: 1, move: 1, minor: 1 },
                log: [],
                _ts: 0
            }
            render()
            log('Game reset')
        }

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'm') setMode('move')
            if (e.key.toLowerCase() === 'g') setMode('measure')
            if (e.key.toLowerCase() === 't') setMode('target')
            if (e.key === '.') endTurn()
            if (e.key === 'Escape') {
                stage.drawPathHighlight(null)
                preview = null
                measureStart = null
            }
        })

        // Token selection
        stage.tokenLayer.eventMode = 'static'
        stage.tokenLayer.on('click', (e) => {
            const tgt = e.target
            if (tgt && typeof tgt.name === 'string' && tgt.name.startsWith('token:')) {
                selected = tgt.name.slice('token:'.length)
                updateStatus()
                log(`Selected ${selected}`)
            }
        })

        // Mouse movement for previews
        stage.app.view.addEventListener('mousemove', (e) => {
            if (!selected) return
            const rect = stage.app.view.getBoundingClientRect()
            const pt = { x: e.clientX - rect.left, y: e.clientY - rect.top }
            const cell = stage.worldToCell(pt)
            
            if (mode === 'move') {
                const from = G.board.positions[selected]
                if (!from) return
                const res = Pathing.findPath(G, from, cell)
                if (res && res.path && res.path.length > 1) {
                    stage.drawPathHighlight(res.path)
                } else {
                    stage.drawPathHighlight(null)
                }
            } else if (mode === 'measure' && measureStart) {
                stage.drawPathHighlight([measureStart, cell])
            }
        })

        // Mouse clicks
        stage.app.view.addEventListener('click', (e) => {
            if (!selected) return
            const rect = stage.app.view.getBoundingClientRect()
            const pt = { x: e.clientX - rect.left, y: e.clientY - rect.top }
            const cell = stage.worldToCell(pt)
            
            if (mode === 'measure') {
                if (!measureStart) {
                    measureStart = cell
                    stage.drawPathHighlight([measureStart, cell])
                } else {
                    const dist = Math.max(Math.abs(cell.x - measureStart.x), Math.abs(cell.y - measureStart.y))
                    log(`Distance: ${measureStart.x},${measureStart.y} → ${cell.x},${cell.y} = ${dist}`)
                    measureStart = null
                    stage.drawPathHighlight(null)
                }
                return
            }
            
            if (mode === 'move') {
                const from = G.board.positions[selected]
                if (!from) return
                const res = Pathing.findPath(G, from, cell)
                if (!res) {
                    log('Path blocked')
                    return
                }
                // Move the token (both locally and via server)
                const to = res.path[res.path.length - 1]
                moveToken(selected, to, 'walk')
                stage.drawPathHighlight(null)
                log(`Moving ${selected} to ${to.x},${to.y} (cost: ${res.cost})`)
            } else if (mode === 'target') {
                const attacker = G.board.positions[selected]
                if (!attacker) return
                
                // Simple burst targeting
                const burst = Templates.cellsForBurst(cell, 1, G.board)
                stage.drawTemplateCells(burst, G.board)
                log(`Targeting burst at ${cell.x},${cell.y}`)
            }
        })

        // Initialize
        createMatch().then(() => {
            log('Ready! Click "Bootstrap Demo" to load demo data.')
        })

        // Expose helpers globally for debugging
        window.G = G
        window.stage = stage
        window.Pathing = Pathing
        window.Templates = Templates
    </script>
</body>
</html>
