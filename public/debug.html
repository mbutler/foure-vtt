<!DOCTYPE html>
<html>
<head>
    <title>4e VTT Debug</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        .section { margin: 20px 0; padding: 10px; border: 1px solid #ccc; }
        button { margin: 5px; padding: 5px 10px; }
        pre { background: #f5f5f5; padding: 10px; overflow-x: auto; }
        .log-entry { margin: 2px 0; padding: 2px 5px; background: #f0f0f0; }
        .log-turn-begin { background: #e8f5e8; }
        .log-turn-end { background: #ffe8e8; }
        .log-save { background: #e8f0ff; }
        .log-roll { background: #fff8e8; }
    </style>
</head>
<body>
    <h1>4e VTT Engine Debug</h1>
    <div class="section">
        <h3>Local Engine Demo (no server required)</h3>
        <div style="margin-bottom: 8px;">
            <label>Seed: <input id="seed" type="number" value="42" style="width: 80px;" /></label>
            <button id="btn-init">Init Game</button>
            <button id="btn-set-init">Set Initiative A1,A2,A3</button>
            <button id="btn-advance">Advance Turn</button>
            <button id="btn-spend-standard">Spend Standard</button>
            <button id="btn-spend-move">Spend Move</button>
            <button id="btn-spend-minor">Spend Minor</button>
            <button id="btn-roll">Roll d20</button>
            <button id="btn-delay">Delay</button>
            <button id="btn-ready">Ready</button>
        </div>
        <div style="display:flex; gap: 20px;">
            <div style="flex:1;">
                <h4>State</h4>
                <pre id="state"></pre>
            </div>
            <div style="flex:1;">
                <h4>Log</h4>
                <div id="log"></div>
            </div>
        </div>
    </div>

    <div class="section">
      <h3>Reactive (F) Demo</h3>
      <div style="display:flex; gap: 10px; align-items: center; flex-wrap: wrap;">
        <div>
          <button id="btn-open-oa">Open OA (E1 vs A1)</button>
          <button id="btn-resolve-oa">Resolve OA (demo)</button>
        </div>
        <div>
          <button id="btn-open-int">Open Interrupt (A1)</button>
          <button id="btn-resolve-int">Resolve Interrupt (demo)</button>
        </div>
        <div>
          <button id="btn-open-react">Open Reaction (A1)</button>
          <button id="btn-resolve-react">Resolve Reaction (demo)</button>
        </div>
      </div>
    </div>
    <div class="section">
        <h3>Grid & Movement (B)</h3>
        <div style="display:flex; gap: 20px; flex-wrap: wrap; align-items: center;">
            <div>
                <div><b>Board</b></div>
                <label>W <input id="b-w" type="number" value="10" style="width:60px"/></label>
                <label>H <input id="b-h" type="number" value="10" style="width:60px"/></label>
                <button id="btn-board-size">Set Size</button>
            </div>
            <div>
                <div><b>Actors</b></div>
                <div>
                  A1: x <input id="a1-x" type="number" value="1" style="width:50px"/> y <input id="a1-y" type="number" value="1" style="width:50px"/>
                  team <select id="a1-team"><option>A</option><option>B</option></select>
                  speed <input id="a1-speed" type="number" value="6" style="width:60px"/>
                  <button id="btn-set-a1">Place A1</button>
                </div>
                <div>
                  E1: x <input id="e1-x" type="number" value="3" style="width:50px"/> y <input id="e1-y" type="number" value="3" style="width:50px"/>
                  team <select id="e1-team"><option>A</option><option selected>B</option></select>
                  speed <input id="e1-speed" type="number" value="6" style="width:60px"/>
                  <button id="btn-set-e1">Place E1</button>
                </div>
            </div>
            <div>
                <div><b>Terrain</b></div>
                <div>Blocker x <input id="blk-x" type="number" value="5" style="width:50px"/> y <input id="blk-y" type="number" value="5" style="width:50px"/> <button id="btn-add-blocker">Add</button></div>
                <div>Difficult x <input id="dif-x" type="number" value="2" style="width:50px"/> y <input id="dif-y" type="number" value="2" style="width:50px"/> <button id="btn-add-difficult">Add</button></div>
            </div>
            <div>
                <div><b>Preview / Move</b></div>
                <div>Actor <select id="mv-actor"><option>A1</option><option>E1</option></select>
                Mode <select id="mv-mode"><option>walk</option><option>shift</option><option>run</option></select>
                to x <input id="mv-x" type="number" value="4" style="width:50px"/> y <input id="mv-y" type="number" value="4" style="width:50px"/>
                <button id="btn-preview">Preview</button>
                <button id="btn-commit">Commit</button></div>
                <div id="preview-out" style="font-size:12px; color:#333; margin-top:4px;"></div>
            </div>
            <div>
                <div><b>Reachable</b></div>
                <div>Actor <select id="rch-actor"><option>A1</option><option>E1</option></select>
                Speed <input id="rch-speed" type="number" value="6" style="width:60px"/>
                <button id="btn-reachable">Compute</button></div>
                <div id="reachable-out" style="font-size:12px; max-width:320px; white-space:normal;"></div>
            </div>
            <div>
                <div><b>Forced</b></div>
                <div>Kind <select id="fm-kind"><option>push</option><option>pull</option><option>slide</option></select>
                Src <select id="fm-src"><option>A1</option><option>E1</option></select>
                Tgt <select id="fm-tgt"><option>E1</option><option>A1</option></select>
                n <input id="fm-n" type="number" value="2" style="width:60px"/>
                <button id="btn-forced">Apply</button></div>
            </div>
        </div>
        <div style="margin-top:10px">
          <h4>Grid</h4>
          <pre id="grid"></pre>
        </div>
    </div>

    <div class="section">
      <h3>Targeting (C)</h3>
      <div style="display:flex; gap: 20px; flex-wrap: wrap; align-items: center;">
        <div>
          <div><b>Spec</b></div>
          Kind <select id="tg-kind"><option>single</option><option>burst</option></select>
          Origin <select id="tg-origin"><option>ranged</option><option>area</option><option>melee</option><option>close</option></select>
          Radius <input id="tg-radius" type="number" value="1" style="width:60px"/>
          Range <input id="tg-range" type="number" value="6" style="width:60px"/>
        </div>
        <div>
          <div><b>Choices</b></div>
          Center x <input id="tg-cx" type="number" value="2" style="width:50px"/> y <input id="tg-cy" type="number" value="2" style="width:50px"/>
          Facing dx <input id="tg-fdx" type="number" value="1" style="width:50px"/> dy <input id="tg-fdy" type="number" value="0" style="width:50px"/>
        </div>
        <div>
          <div><b>Actions</b></div>
          Attacker <select id="tg-attacker"><option>A1</option><option>E1</option></select>
          <button id="btn-target-preview">Preview Targeting</button>
          <button id="btn-target-stage">Stage Selection</button>
        </div>
      </div>
      <div id="target-out" style="font-size:12px; margin-top:6px;"></div>
    </div>

    <script>
        // --- Minimal local engine (mirrors src/engine + src/rules) ---
        const getAtPath = (obj, path) => path.split('.').reduce((acc, k) => acc ? acc[k] : undefined, obj);
        const setAtPath = (obj, path, value) => {
          const keys = path.split('.');
          let ref = obj;
          for (let i = 0; i < keys.length - 1; i++) {
            const k = keys[i];
            ref[k] = ref[k] ?? {};
            ref = ref[k];
          }
          ref[keys[keys.length - 1]] = value;
        };
        function applyPatches(G, patches = []) {
          for (const p of patches) {
            switch (p.type) {
              case 'set': {
                if (p.value === undefined) {
                  const keys = p.path.split('.');
                  let ref = G;
                  for (let i = 0; i < keys.length - 1; i++) {
                    const k = keys[i];
                    ref[k] = ref[k] ?? {};
                    ref = ref[k];
                  }
                  delete ref[keys[keys.length - 1]];
                } else {
                  setAtPath(G, p.path, p.value);
                }
                break;
              }
              case 'inc': {
                const current = getAtPath(G, p.path) || 0;
                setAtPath(G, p.path, current + p.value);
                break;
              }
              case 'merge': {
                const target = getAtPath(G, p.path) ?? {};
                setAtPath(G, p.path, { ...target, ...p.value });
                break;
              }
              case 'add': {
                const array = getAtPath(G, p.path) || [];
                setAtPath(G, p.path, [...array, p.value]);
                break;
              }
              case 'remove': {
                const arr = getAtPath(G, p.path) || [];
                setAtPath(G, p.path, arr.filter(item => item !== p.value));
                break;
              }
              case 'log': {
                const log = getAtPath(G, 'log') || [];
                setAtPath(G, 'log', [...log, { ts: G._ts + 1, ...p.value }]);
                setAtPath(G, '_ts', G._ts + 1);
                break;
              }
            }
          }
        }
        function prng(seed, cursor) {
          let t = (seed + cursor) >>> 0;
          const nextFloat = () => {
            t += 0x6d2b79f5;
            let x = Math.imul(t ^ (t >>> 15), 1 | t);
            x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
            return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
          };
          return { nextFloat, cursor: cursor + 1 };
        }
        function roll(G, spec) {
          const { nextFloat, cursor } = prng(G.rng.seed, G.rng.cursor);
          let result = Math.floor(nextFloat() * 20) + 1;
          const parts = [result];
          const patches = [
            { type: 'set', path: 'rng.cursor', value: cursor },
            { type: 'log', value: { type: 'roll', msg: `Rolled ${spec}`, data: { spec, result, parts }, rng: { seed: G.rng.seed, idx: G.rng.cursor } } }
          ];
          return { result, parts, patches };
        }
        function initialState(seed = 42) {
          return {
            matchId: `match_${Date.now()}_${seed}`,
            rng: { seed, cursor: 0 },
            round: 1,
            turn: { order: [], index: 0 },
            actions: { standard: 1, move: 1, minor: 1, free: 'unbounded', immediateUsedThisRound: false },
            actors: {},
            board: { w: 20, h: 20, blockers: [], difficult: [], positions: {} },
            effects: {},
            queue: [],
            prompts: { current: null },
            log: [],
            _ts: 0
          };
        }
        function setInitiativeOrder(_G, order) {
          return [
            { type: 'set', path: 'turn.order', value: order },
            { type: 'set', path: 'turn.index', value: 0 },
            { type: 'log', value: { type: 'info', msg: `Initiative set: ${order.join(', ')}` } }
          ];
        }
        function onTurnBegin(G, actorId) {
          const patches = [];
          patches.push({ type: 'set', path: 'actions', value: { standard: 1, move: 1, minor: 1, free: 'unbounded', immediateUsedThisRound: false } });
          patches.push({ type: 'log', value: { type: 'turn-begin', actorId, msg: `${actorId}'s turn begins` } });
          return patches;
        }
        function onTurnEnd(G, actorId) {
          const patches = [];
          patches.push({ type: 'log', value: { type: 'turn-end', actorId, msg: `${actorId}'s turn ends` } });
          return patches;
        }
        function advanceTurn(G) {
          const patches = [];
          if (G.turn.order.length > 0) {
            const currentActorId = G.turn.order[G.turn.index];
            patches.push(...onTurnEnd(G, currentActorId));
          }
          const nextIndex = (G.turn.index + 1) % Math.max(G.turn.order.length, 1);
          patches.push({ type: 'set', path: 'turn.index', value: nextIndex });
          if (nextIndex === 0 && G.turn.order.length > 0) {
            patches.push({ type: 'inc', path: 'round', value: 1 });
            patches.push({ type: 'log', value: { type: 'round-begin', msg: `Round ${G.round + 1} begins` } });
          }
          if (G.turn.order.length > 0) {
            const nextActorId = G.turn.order[nextIndex];
            patches.push(...onTurnBegin(G, nextActorId));
          }
          return patches;
        }
        function canSpendAction(G, kind) {
          const a = G.actions;
          if (kind === 'standard' && a.standard > 0) return { ok: true };
          if (kind === 'move') {
            if (a.move > 0) return { ok: true };
            if (a.standard > 0) return { ok: true, swap: { from: 'standard', to: 'move' } };
            return { ok: false, reason: 'No move or standard action available' };
          }
          if (kind === 'minor') {
            if (a.minor > 0) return { ok: true };
            if (a.move > 0) return { ok: true, swap: { from: 'move', to: 'minor' } };
            if (a.standard > 0) return { ok: true, swap: { from: 'standard', to: 'minor' } };
            return { ok: false, reason: 'No minor, move, or standard action available' };
          }
          if (kind === 'free') return { ok: true };
          return { ok: false, reason: `No ${kind} action available` };
        }
        function spendAction(G, kind) {
          const { ok, reason, swap } = canSpendAction(G, kind);
          if (!ok) return [{ type: 'log', value: { type: 'info', msg: `Warning: ${reason}` } }];
          const patches = [];
          if (kind === 'standard') patches.push({ type: 'inc', path: 'actions.standard', value: -1 });
          else if (kind === 'move') patches.push({ type: 'inc', path: swap && swap.from === 'standard' ? 'actions.standard' : 'actions.move', value: -1 });
          else if (kind === 'minor') {
            if (swap && swap.from === 'move') patches.push({ type: 'inc', path: 'actions.move', value: -1 });
            else if (swap && swap.from === 'standard') patches.push({ type: 'inc', path: 'actions.standard', value: -1 });
            else patches.push({ type: 'inc', path: 'actions.minor', value: -1 });
          }
          patches.push({ type: 'log', value: { type: 'info', msg: swap ? `Spent ${swap.from} as ${kind}` : `Spent ${kind} action` } });
          return patches;
        }

        // --- UI wiring ---
        let G = initialState(Number(document.getElementById('seed').value));
        let lastPreview = null;
        let lastTargetPreview = null;
        const stateEl = document.getElementById('state');
        const logEl = document.getElementById('log');
        const gridEl = document.getElementById('grid');
        function render() {
          stateEl.textContent = JSON.stringify(G, null, 2);
          logEl.innerHTML = '';
          for (const e of G.log.slice(-200)) {
            const div = document.createElement('div');
            const cls = e.type ? `log-${e.type.replace(/_/g,'-')}` : '';
            div.className = `log-entry ${cls}`;
            div.textContent = `[${e.ts}] ${e.type || 'info'}: ${e.msg || ''}`;
            logEl.appendChild(div);
          }
          // Simple ascii grid
          const { w, h } = G.board;
          let out = '';
          const blockers = new Set(G.board.blockers || []);
          const difficult = new Set(G.board.difficult || []);
          const posToActor = new Map(Object.entries(G.board.positions || {}).map(([id, p]) => [ `${p.x},${p.y}`, id ]));
          for (let y = 0; y < h; y++) {
            let row = '';
            for (let x = 0; x < w; x++) {
              const id = `${x},${y}`;
              if (posToActor.has(id)) {
                const aid = posToActor.get(id);
                row += aid === 'A1' ? 'A' : 'E';
              } else if (blockers.has(id)) row += '#';
              else if (difficult.has(id)) row += '~';
              else row += '.';
            }
            out += row + "\n";
          }
          gridEl.textContent = out;
        }
        render();
        document.getElementById('btn-init').onclick = () => {
          const seed = Number(document.getElementById('seed').value) || 42;
          G = initialState(seed);
          applyPatches(G, [{ type: 'log', value: { type: 'info', msg: `Game initialized with seed ${seed}` } }]);
          render();
        };
        document.getElementById('btn-set-init').onclick = () => {
          applyPatches(G, setInitiativeOrder(G, ['A1','A2','A3']));
          render();
        };
        document.getElementById('btn-advance').onclick = () => { applyPatches(G, advanceTurn(G)); render(); };
        document.getElementById('btn-spend-standard').onclick = () => { applyPatches(G, spendAction(G, 'standard')); render(); };
        document.getElementById('btn-spend-move').onclick = () => { applyPatches(G, spendAction(G, 'move')); render(); };
        document.getElementById('btn-spend-minor').onclick = () => { applyPatches(G, spendAction(G, 'minor')); render(); };
        document.getElementById('btn-roll').onclick = () => { const r = roll(G, 'd20'); applyPatches(G, r.patches); render(); };
        document.getElementById('btn-delay').onclick = () => { applyPatches(G, [{ type: 'add', path: 'queue', value: { type: 'delay', actorId: G.turn.order[G.turn.index], round: G.round } }, { type: 'log', value: { type: 'delay', msg: `${G.turn.order[G.turn.index]} delays` } }]); render(); };
        document.getElementById('btn-ready').onclick = () => { applyPatches(G, [...spendAction(G, 'standard'), { type: 'add', path: 'queue', value: { type: 'ready', actorId: G.turn.order[G.turn.index], round: G.round } }, { type: 'log', value: { type: 'ready', msg: `${G.turn.order[G.turn.index]} readies` } }]); render(); };

        // --- Grid & movement (B) helpers ---
        const chebyshev = (a,b) => Math.max(Math.abs(a.x-b.x), Math.abs(a.y-b.y));
        const toId = ({x,y}) => `${x},${y}`;
        const inBounds = ({x,y},{w,h}) => x>=0 && y>=0 && x<w && y<h;
        const neighbors8 = p => [
          { x: p.x + 1, y: p.y },
          { x: p.x - 1, y: p.y },
          { x: p.x, y: p.y + 1 },
          { x: p.x, y: p.y - 1 },
          { x: p.x + 1, y: p.y + 1 },
          { x: p.x - 1, y: p.y + 1 },
          { x: p.x + 1, y: p.y - 1 },
          { x: p.x - 1, y: p.y - 1 }
        ];
        const actorAt = (G, cell) => {
          const id = toId(cell);
          for (const [aid, pos] of Object.entries(G.board.positions || {})) {
            if (toId(pos) === id) return aid;
          }
          return null;
        };
        const isBlocker = (id, set) => set.has(id);
        const isDifficult = (id, set) => set.has(id);
        const stepCost = (id, difficult) => isDifficult(id, difficult) ? 2 : 1;
        const areEnemies = (G, aId, bId) => {
          if (!aId || !bId) return false;
          const a = (G.actors && G.actors[aId]) || {}; const b = (G.actors && G.actors[bId]) || {};
          return a.team && b.team ? a.team !== b.team : false;
        };
        function findPath(G, start, goal, options={}) {
          const opts = { difficult: new Set(G.board.difficult || []), blockers: new Set(G.board.blockers || []), board: G.board, allowAllyPassThrough: true, ...options };
          if (!inBounds(start, opts.board) || !inBounds(goal, opts.board)) return null;
          const startId = toId(start); const goalId = toId(goal);
          if (isBlocker(goalId, opts.blockers)) return null;
          const open = new Map([[startId,0]]);
          const cameFrom = new Map();
          const gScore = new Map([[startId,0]]);
          const heuristic = (a,b) => chebyshev(a,b);
          const getLowestF = () => { let best=null,score=Infinity; for (const [id] of open){ const [xs,ys]=id.split(','); const p={x:Number(xs),y:Number(ys)}; const g=gScore.get(id)??Infinity; const f=g+heuristic(p,goal); if(f<score){score=f;best=id} } return best; };
          while (open.size>0){
            const currentId = getLowestF(); const [cx,cy] = currentId.split(',').map(Number); const current = {x:cx,y:cy};
            if (currentId === goalId){
              const path=[]; let cur=currentId; while(cur){ const [px,py]=cur.split(',').map(Number); path.push({x:px,y:py}); cur=cameFrom.get(cur);} path.reverse();
              let cost=0; for(let i=1;i<path.length;i++){ cost+=stepCost(toId(path[i]), opts.difficult) }
              return { path, cost };
            }
            open.delete(currentId);
            for (const n of neighbors8(current)){
              if (!inBounds(n, opts.board)) continue; const nid = toId(n); if (isBlocker(nid, opts.blockers)) continue;
              const occ = actorAt(G, n); const isEnd = nid===goalId;
              if (occ){ if (opts.moverId && areEnemies(G, opts.moverId, occ)) continue; if (isEnd) continue; if (!opts.allowAllyPassThrough) continue; }
              const tentative = (gScore.get(currentId)??Infinity) + stepCost(nid, opts.difficult);
              const existing = gScore.get(nid);
              if (existing===undefined || tentative<existing){ cameFrom.set(nid, currentId); gScore.set(nid, tentative); open.set(nid, tentative); }
            }
          }
          return null;
        }
        function reachable(G, actorId, speed){
          const opts = { difficult: new Set(G.board.difficult || []), blockers: new Set(G.board.blockers || []) };
          const start = G.board.positions[actorId]; if (!start) return new Set(); const startId = toId(start);
          const visited=new Map([[startId,0]]); const q=[start];
          while(q.length){ const cur=q.shift(); const cid=toId(cur); const curCost=visited.get(cid)??0; for(const n of neighbors8(cur)){ if(!inBounds(n,G.board)) continue; const nid=toId(n); if(isBlocker(nid, opts.blockers)) continue; const step=stepCost(nid, opts.difficult); const newCost=curCost+step; if(newCost>speed) continue; const occ=actorAt(G,n); if (occ && areEnemies(G, actorId, occ)) continue; if(!visited.has(nid) || newCost<(visited.get(nid)??Infinity)){ visited.set(nid,newCost); q.push(n);} } }
          const res=new Set(); for(const [id] of visited.entries()){ if(id===startId){res.add(id); continue;} const [x,y]=id.split(',').map(Number); if(!actorAt(G,{x,y})) res.add(id);} return res;
        }
        function detectOAFromMovement(G, moverId, path){
          const prov=new Set(); const cells=[]; if(!Array.isArray(path)||path.length<2) return {provokers:[],cells:[]};
          for(let i=0;i<path.length-1;i++){ const from=path[i]; for(const [otherId,pos] of Object.entries(G.board.positions||{})){ if(otherId===moverId) continue; if (chebyshev(pos, from) <= 1){ prov.add(otherId); cells.push(toId(from)); } } }
          return { provokers: Array.from(prov), cells };
        }
        function buildMovePreviewLogLocal(actorId, preview, mode){
          return [{ type: 'log', value: { type: 'move-preview', msg: `Preview ${mode} for ${actorId}`, data: { actorId, mode, from: preview.path[0], to: preview.path[preview.path.length-1], path: preview.path, cost: preview.cost, warns: preview.warns||[] } } }];
        }
        function commitMoveLocal(G, actorId, preview){
          const to = preview.path[preview.path.length-1];
          return [ { type: 'set', path: `board.positions.${actorId}`, value: to }, { type: 'inc', path: 'actions.move', value: -1 }, { type: 'log', value: { type: 'move-commit', msg: `Moved ${actorId} to ${to.x},${to.y}`, data: { actorId, from: preview.path[0], to, path: preview.path, cost: preview.cost } } } ];
        }
        function previewMoveLocal(G, actorId, toCell, mode){
          const from = G.board.positions[actorId]; if(!from) return { ok:false, reason:'no-position' };
          const baseSpeed = (G.actors[actorId] && G.actors[actorId].speed) || 6; const speedBonus = mode==='run'?2:0; const maxBudget = baseSpeed + speedBonus;
          if(mode==='shift'){ const dx=Math.abs(toCell.x-from.x),dy=Math.abs(toCell.y-from.y); if(Math.max(dx,dy)!==1) return {ok:false, reason:'shift-distance'}; const to = toId(toCell); if((G.board.difficult||[]).includes(to)) return { ok:false, reason:'difficult' }; }
          const res = findPath(G, from, toCell, { moverId: actorId }); if(!res) return { ok:false, reason:'blocked' }; if (mode==='shift' && res.path.length!==2) return { ok:false, reason:'shift-path' };
          const warns=[]; if(res.cost>maxBudget) warns.push({ type:'range', cost: res.cost, max: maxBudget }); const oa=detectOAFromMovement(G, actorId, res.path); if(oa.provokers.length>0 && mode!=='shift') warns.push({ type:'oa', provokers: oa.provokers, cells: oa.cells });
          return { ok:true, path: res.path, cost: res.cost, warns };
        }
        const forcedLocal = {
          push(G, sourceId, targetId, n){ const src=G.board.positions[sourceId], start=G.board.positions[targetId]; if(!src||!start) return []; let cur=start; const path=[cur]; for(let i=0;i<n;i++){ const step={ x: Math.sign(cur.x-src.x), y: Math.sign(cur.y-src.y) }; const next={ x: cur.x+step.x, y: cur.y+step.y }; const id=toId(next); if(!inBounds(next,G.board) || (G.board.blockers||[]).includes(id)) break; cur=next; path.push(cur);} const patches=[]; const fin=path[path.length-1]; if(fin.x!==start.x||fin.y!==start.y) patches.push({ type:'set', path:`board.positions.${targetId}`, value: fin }); patches.push({ type:'log', value:{ type:'forced-move', msg:`${targetId} pushed`, data:{ kind:'push', sourceId, targetId, n, path } } }); return patches; },
          pull(G, sourceId, targetId, n){ const src=G.board.positions[sourceId], start=G.board.positions[targetId]; if(!src||!start) return []; let cur=start; const path=[cur]; for(let i=0;i<n;i++){ if(chebyshev(cur,src)<=1) break; const neigh=neighbors8(cur).filter(c=>chebyshev(c,src)<chebyshev(cur,src)); let moved=false; for(const c of neigh){ const id=toId(c); if(!inBounds(c,G.board) || (G.board.blockers||[]).includes(id)) continue; cur=c; path.push(cur); moved=true; break; } if(!moved) break; } const patches=[]; const fin=path[path.length-1]; if(fin.x!==start.x||fin.y!==start.y) patches.push({ type:'set', path:`board.positions.${targetId}`, value: fin }); patches.push({ type:'log', value:{ type:'forced-move', msg:`${targetId} pulled`, data:{ kind:'pull', sourceId, targetId, n, path } } }); return patches; },
          slide(G, _sourceId, targetId, n){ const start=G.board.positions[targetId]; if(!start) return []; let cur=start; const path=[cur]; for(let i=0;i<n;i++){ const neigh=neighbors8(cur); const c=neigh[0]; if(!c) break; const id=toId(c); if(!inBounds(c,G.board) || (G.board.blockers||[]).includes(id)) break; cur=c; path.push(cur);} const patches=[]; const fin=path[path.length-1]; if(fin.x!==start.x||fin.y!==start.y) patches.push({ type:'set', path:`board.positions.${targetId}`, value: fin }); patches.push({ type:'log', value:{ type:'forced-move', msg:`${targetId} slid`, data:{ kind:'slide', targetId, n, path } } }); return patches; }
        };

        // B controls wiring
        document.getElementById('btn-board-size').onclick = () => { const w=Number(document.getElementById('b-w').value)||10; const h=Number(document.getElementById('b-h').value)||10; applyPatches(G, [{ type:'set', path:'board.w', value:w }, { type:'set', path:'board.h', value:h }, { type:'log', value:{ type:'info', msg:`Board size set to ${w}x${h}` } }]); render(); };
        document.getElementById('btn-set-a1').onclick = () => { const x=Number(document.getElementById('a1-x').value)||0; const y=Number(document.getElementById('a1-y').value)||0; const team=document.getElementById('a1-team').value; const speed=Number(document.getElementById('a1-speed').value)||6; applyPatches(G, [{ type:'set', path:'board.positions.A1', value:{x,y} }, { type:'merge', path:'actors.A1', value:{ team, speed } }, { type:'log', value:{ type:'info', msg:`A1 at ${x},${y} (team ${team})` } }]); render(); };
        document.getElementById('btn-set-e1').onclick = () => { const x=Number(document.getElementById('e1-x').value)||0; const y=Number(document.getElementById('e1-y').value)||0; const team=document.getElementById('e1-team').value; const speed=Number(document.getElementById('e1-speed').value)||6; applyPatches(G, [{ type:'set', path:'board.positions.E1', value:{x,y} }, { type:'merge', path:'actors.E1', value:{ team, speed } }, { type:'log', value:{ type:'info', msg:`E1 at ${x},${y} (team ${team})` } }]); render(); };
        document.getElementById('btn-add-blocker').onclick = () => { const x=Number(document.getElementById('blk-x').value)||0; const y=Number(document.getElementById('blk-y').value)||0; const id=`${x},${y}`; const cur=G.board.blockers||[]; if(!cur.includes(id)) applyPatches(G, [{ type:'set', path:'board.blockers', value:[...cur,id] }, { type:'log', value:{ type:'info', msg:`Blocker ${id}` } }]); render(); };
        document.getElementById('btn-add-difficult').onclick = () => { const x=Number(document.getElementById('dif-x').value)||0; const y=Number(document.getElementById('dif-y').value)||0; const id=`${x},${y}`; const cur=G.board.difficult||[]; if(!cur.includes(id)) applyPatches(G, [{ type:'set', path:'board.difficult', value:[...cur,id] }, { type:'log', value:{ type:'info', msg:`Difficult ${id}` } }]); render(); };
        document.getElementById('btn-preview').onclick = () => { const actor=document.getElementById('mv-actor').value; const mode=document.getElementById('mv-mode').value; const x=Number(document.getElementById('mv-x').value)||0; const y=Number(document.getElementById('mv-y').value)||0; lastPreview = previewMoveLocal(G, actor, {x,y}, mode); if(lastPreview.ok){ applyPatches(G, buildMovePreviewLogLocal(actor, lastPreview, mode)); document.getElementById('preview-out').textContent = `OK: cost=${lastPreview.cost}, path=${lastPreview.path.map(p=>`${p.x},${p.y}`).join(' -> ')}, warns=${JSON.stringify(lastPreview.warns)}`; } else { document.getElementById('preview-out').textContent = `Blocked: ${lastPreview.reason}`; } render(); };
        document.getElementById('btn-commit').onclick = () => { if(!lastPreview || !lastPreview.ok){ alert('No valid preview'); return; } const actor=document.getElementById('mv-actor').value; applyPatches(G, commitMoveLocal(G, actor, lastPreview)); render(); };
        document.getElementById('btn-reachable').onclick = () => { const actor=document.getElementById('rch-actor').value; const speed=Number(document.getElementById('rch-speed').value)||6; const set=reachable(G, actor, speed); document.getElementById('reachable-out').textContent = `Count ${set.size}: ${Array.from(set).slice(0,100).join(', ')}${set.size>100?' ...':''}`; };
        document.getElementById('btn-forced').onclick = () => { const kind=document.getElementById('fm-kind').value; const src=document.getElementById('fm-src').value; const tgt=document.getElementById('fm-tgt').value; const n=Number(document.getElementById('fm-n').value)||1; const patches = kind==='push'? forcedLocal.push(G, src, tgt, n) : kind==='pull'? forcedLocal.pull(G, src, tgt, n) : forcedLocal.slide(G, src, tgt, n); applyPatches(G, patches); render(); };

        // Reactive (F) enqueue/resolve demo (no full resolution here)
        document.getElementById('btn-open-oa').onclick = () => { applyPatches(G, [ { type:'add', path:'queue', value:{ id:`ev_${(G._ts||0)+(G.queue?G.queue.length:0)+1}`, kind:'OA', trigger:{ type:'movement', data:{ moverId:'A1' } }, eligible:['E1'], status:'open' } }, { type:'log', value:{ type:'oa-open', msg:'OA open (demo)' } } ]); render(); };
        document.getElementById('btn-resolve-oa').onclick = () => {
          const ev = (G.queue||[]).find(e => e.kind === 'OA')
          if (!ev) { applyPatches(G, [{ type:'log', value:{ type:'info', msg:'No OA event' } }]); return }
          const attacker = 'E1'
          const target = ev.trigger && ev.trigger.data && ev.trigger.data.moverId || 'A1'
          // roll to hit: d20 + 4 vs AC 10
          const r = (function(){ const spec = { kind:'sum', terms:['d20'] }; const { result, patches } = (function(spec){ const { nextFloat, cursor } = (function(seed,cursor){ let t=(seed+cursor)>>>0; const nextFloat=()=>{ t+=0x6d2b79f5; let x=Math.imul(t^(t>>>15),1|t); x^=x+Math.imul(x^(x>>>7),61|x); return ((x^(x>>>14))>>>0)/4294967296 }; return { nextFloat, cursor: cursor+1 } })(G.rng.seed, G.rng.cursor); let res, parts; if(spec.kind==='sum'){ parts=spec.terms.map(term => term==='d20'? Math.floor(nextFloat()*20)+1 : 0); res=parts.reduce((a,b)=>a+b,0) } else { res=1; parts=[1] } const patches=[ { type:'set', path:'rng.cursor', value: cursor }, { type:'log', value:{ type:'roll', msg:`Rolled ${'d20'}`, data:{ spec:'d20', result: res, parts }, rng:{ seed:G.rng.seed, idx:G.rng.cursor } } } ]; return { result: res, parts, patches } })(spec); return { d20: result, patches } })()
          applyPatches(G, r.patches)
          const toHit = r.d20 + 4
          const defense = 10
          const hit = r.d20 !== 1 && (r.d20 === 20 || toHit >= defense)
          applyPatches(G, [{ type:'log', value:{ type:'attack-roll', msg:`OA roll (demo)`, data:{ d20:r.d20, toHit, defense } } }])
          if (hit) {
            // damage 1d6
            const dr = (function(){ const spec = { kind:'sum', terms:['d6'] }; const { result, patches } = (function(spec){ const { nextFloat, cursor } = (function(seed,cursor){ let t=(seed+cursor)>>>0; const nextFloat=()=>{ t+=0x6d2b79f5; let x=Math.imul(t^(t>>>15),1|t); x^=x+Math.imul(x^(x>>>7),61|x); return ((x^(x>>>14))>>>0)/4294967296 }; return { nextFloat, cursor: cursor+1 } })(G.rng.seed, G.rng.cursor); let res, parts; if(spec.kind==='sum'){ parts=spec.terms.map(term => term==='d6'? Math.floor(nextFloat()*6)+1 : 0); res=parts.reduce((a,b)=>a+b,0) } else { res=1; parts=[1] } const patches=[ { type:'set', path:'rng.cursor', value: cursor }, { type:'log', value:{ type:'roll', msg:`Rolled ${'d6'}`, data:{ spec:'d6', result: res, parts }, rng:{ seed:G.rng.seed, idx:G.rng.cursor } } } ]; return { result: res, parts, patches } })(spec); return { dmg: result, patches } })()
            applyPatches(G, dr.patches)
            // ensure hp field
            const hp = (((G.actors||{})[target] = (G.actors||{})[target] || {}), G.actors[target].hp = G.actors[target].hp || { current: 10, max: 10, temp: 0 }, G.actors[target].hp)
            const before = { hp: hp.current, temp: hp.temp }
            const afterTemp = Math.max(0, hp.temp - dr.dmg)
            const remaining = Math.max(0, dr.dmg - hp.temp)
            const afterHp = Math.max(0, hp.current - remaining)
            applyPatches(G, [ { type:'set', path:`actors.${target}.hp.temp`, value: afterTemp }, { type:'set', path:`actors.${target}.hp.current`, value: afterHp }, { type:'log', value:{ type:'damage-apply', msg:`OA damage to ${target} (demo)`, data:{ before, after:{ hp: afterHp, temp: afterTemp }, final: remaining } } } ])
          }
          applyPatches(G, [ { type:'log', value:{ type:'oa-resolve', msg:'OA resolved (demo)' } } ])
          render();
        };
        document.getElementById('btn-open-int').onclick = () => { applyPatches(G, [ { type:'add', path:'queue', value:{ id:`ev_${(G._ts||0)+(G.queue?G.queue.length:0)+1}`, kind:'INTERRUPT', trigger:{ type:'attack-hit', data:{} }, eligible:['A1'], status:'open' } }, { type:'log', value:{ type:'int-open', msg:'Interrupt open (demo)' } } ]); render(); };
        document.getElementById('btn-resolve-int').onclick = () => { applyPatches(G, [ { type:'log', value:{ type:'int-resolve', msg:'Interrupt resolved (demo)' } } ]); render(); };
        document.getElementById('btn-open-react').onclick = () => { applyPatches(G, [ { type:'add', path:'queue', value:{ id:`ev_${(G._ts||0)+(G.queue?G.queue.length:0)+1}`, kind:'REACTION', trigger:{ type:'after-damage', data:{} }, eligible:['A1'], status:'open' } }, { type:'log', value:{ type:'react-open', msg:'Reaction open (demo)' } } ]); render(); };
        document.getElementById('btn-resolve-react').onclick = () => { applyPatches(G, [ { type:'log', value:{ type:'react-resolve', msg:'Reaction resolved (demo)' } } ]); render(); };

        // --- Targeting (C) helpers ---
        function cellsForBurstLocal(center, radius){
          const cells = new Set();
          for(let dx=-radius; dx<=radius; dx++){
            for(let dy=-radius; dy<=radius; dy++){
              const cell={ x:center.x+dx, y:center.y+dy };
              if(Math.max(Math.abs(dx),Math.abs(dy))<=radius && inBounds(cell,G.board)) cells.add(toId(cell));
            }
          }
          return cells;
        }
        function supercoverCells(x0,y0,x1,y1){
          const cells=new Set(); const dx=x1-x0, dy=y1-y0; const steps=Math.max(Math.abs(dx),Math.abs(dy))*4+1;
          for(let i=0;i<=steps;i++){ const t=i/steps; const x=x0+dx*t, y=y0+dy*t; const cx=Math.floor(x), cy=Math.floor(y); cells.add(`${cx},${cy}`); }
          return cells;
        }
        function hasLoELocal(fromCell,toCell){
          if(fromCell.x===toCell.x && fromCell.y===toCell.y) return true;
          const blockers=new Set(G.board.blockers||[]);
          const fromId=toId(fromCell); const toIdStr=toId(toCell);
          const corners = c => [{x:c.x+0,y:c.y+0},{x:c.x+1,y:c.y+0},{x:c.x+0,y:c.y+1},{x:c.x+1,y:c.y+1}];
          for(const a of corners(fromCell)){
            for(const b of corners(toCell)){
              const cells=supercoverCells(a.x,a.y,b.x,b.y);
              let blocked=false; for(const cid of cells){ if(cid===fromId||cid===toIdStr) continue; if(blockers.has(cid)){ blocked=true; break; } }
              if(!blocked) return true;
            }
          }
          return false;
        }
        function buildTargetPreviewLogLocal(attackerId, spec, preview, choices){
          const data={ attackerId, spec, center: choices.center||null, facing: choices.facing||null, templateCellsCount: preview&&preview.templateCells?preview.templateCells.size:0, candidateCount: preview&&preview.targets?preview.targets.length:0, errors: preview&&preview.errors||[], warnings: preview&&preview.warnings||[] };
          return [{ type:'log', value:{ type:'target-preview', msg:`Target preview by ${attackerId}`, data } }];
        }
        function stageTargetingSelectionLocal(G, attackerId, spec, choices, targets){
          return [ { type:'set', path:'staging.targeting', value:{ attackerId, spec, center: choices.center||null, facing: choices.facing||null, targets } }, { type:'log', value:{ type:'template-choose', msg:`${attackerId} staged targeting`, data:{ attackerId, targets, center:choices.center||null, facing:choices.facing||null } } } ];
        }
        function previewTargetingLocal(G, attackerId, spec, choices){
          const attackerCell=G.board.positions[attackerId]; const res={ templateCells:new Set(), targets:[], errors:[], warnings:[] };
          if(!attackerCell){ res.errors.push('NO_ATTACKER_POSITION'); return res; }
          if(spec.kind==='burst'){
            if(spec.origin==='area'){
              const center=choices.center; if(!center){ res.errors.push('CENTER_REQUIRED'); return res; }
              if(spec.range!=null && chebyshev(attackerCell, center) > spec.range) res.errors.push('OUT_OF_RANGE');
              if(spec.requiresLoEToOrigin && !hasLoELocal(attackerCell, center)) res.errors.push('NO_LOE_TO_ORIGIN');
              res.templateCells=cellsForBurstLocal(center, spec.radius||1);
            } else {
              res.templateCells=cellsForBurstLocal(attackerCell, spec.radius||1);
            }
          } else if (spec.kind==='single'){
            const range = spec.origin==='melee' ? (spec.reach||1) : (spec.range||6);
            for(let x=0;x<G.board.w;x++){ for(let y=0;y<G.board.h;y++){ const cell={x,y}; if(chebyshev(attackerCell, cell)<=range) res.templateCells.add(toId(cell)); }}
          }
          if(res.errors.length>0) return res;
          const candidates=[]; for(const [aid,pos] of Object.entries(G.board.positions||{})){ const id=toId(pos); if(res.templateCells.has(id)) candidates.push(aid); }
          const originCell = (spec.origin==='area' && choices.center)? choices.center : attackerCell;
          const requiresLoE = spec.origin==='ranged' || spec.origin==='area' || spec.requiresLoEToOrigin;
          const filtered = candidates.filter(tid => !requiresLoE || hasLoELocal(originCell, G.board.positions[tid]));
          res.targets = filtered;
          return res;
        }
        document.getElementById('btn-target-preview').onclick = () => {
          const attacker = document.getElementById('tg-attacker').value;
          const kind = document.getElementById('tg-kind').value;
          const origin = document.getElementById('tg-origin').value;
          const radius = Number(document.getElementById('tg-radius').value)||1;
          const range = Number(document.getElementById('tg-range').value)||6;
          const center = { x: Number(document.getElementById('tg-cx').value)||0, y: Number(document.getElementById('tg-cy').value)||0 };
          const facing = { x: Number(document.getElementById('tg-fdx').value)||1, y: Number(document.getElementById('tg-fdy').value)||0 };
          const spec = { kind, origin, radius, range, requiresLoEToOrigin: origin!=='close' && origin!=='melee' };
          const choices = { center, facing };
          lastTargetPreview = previewTargetingLocal(G, attacker, spec, choices);
          applyPatches(G, buildTargetPreviewLogLocal(attacker, spec, lastTargetPreview, choices));
          const cells = Array.from(lastTargetPreview.templateCells||[]);
          document.getElementById('target-out').textContent = `Errors: ${JSON.stringify(lastTargetPreview.errors)}; Warnings: ${JSON.stringify(lastTargetPreview.warnings)}; TemplateCells(${cells.length}): ${cells.slice(0,80).join(', ')}`;
          render();
        };
        document.getElementById('btn-target-stage').onclick = () => {
          if(!lastTargetPreview || (lastTargetPreview.errors||[]).length>0){ alert('No valid preview'); return; }
          const attacker = document.getElementById('tg-attacker').value;
          const kind = document.getElementById('tg-kind').value;
          const origin = document.getElementById('tg-origin').value;
          const radius = Number(document.getElementById('tg-radius').value)||1;
          const range = Number(document.getElementById('tg-range').value)||6;
          const center = { x: Number(document.getElementById('tg-cx').value)||0, y: Number(document.getElementById('tg-cy').value)||0 };
          const facing = { x: Number(document.getElementById('tg-fdx').value)||1, y: Number(document.getElementById('tg-fdy').value)||0 };
          const spec = { kind, origin, radius, range };
          const targets = lastTargetPreview.targets||[];
          applyPatches(G, stageTargetingSelectionLocal(G, attacker, spec, { center, facing }, targets));
          render();
        };
    </script>
</body>
</html>